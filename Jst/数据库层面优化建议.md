# 数据库层面优化建议

  

## 1. 统计信息更新

```sql

-- 定期更新统计信息，确保查询优化器选择最优执行计划

UPDATE STATISTICS dbo.Inout_1 WITH FULLSCAN;

UPDATE STATISTICS dbo.InoutItem_1 WITH FULLSCAN;

  

-- 设置自动更新统计信息

ALTER DATABASE [YourDatabase] SET AUTO_UPDATE_STATISTICS ON;

ALTER DATABASE [YourDatabase] SET AUTO_UPDATE_STATISTICS_ASYNC ON;

```

  

## 2. 索引维护

```sql

-- 检查索引碎片率

SELECT

    OBJECT_NAME(ips.object_id) AS TableName,

    i.name AS IndexName,

    ips.avg_fragmentation_in_percent,

    ips.page_count

FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'DETAILED') ips

INNER JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id

WHERE ips.avg_fragmentation_in_percent > 10

  AND ips.page_count > 1000

ORDER BY ips.avg_fragmentation_in_percent DESC;

  

-- 重建高碎片率的索引

ALTER INDEX IX_Inout_1_co_id_warehouse_id ON dbo.Inout_1 REBUILD

WITH (FILLFACTOR = 95, ONLINE = ON);

```

  

## 3. 查询计划缓存优化

```sql

-- 清理查询计划缓存（谨慎使用）

DBCC FREEPROCCACHE;

  

-- 查看最耗时的查询

SELECT TOP 10

    qs.total_elapsed_time / qs.execution_count AS avg_elapsed_time,

    qs.total_logical_reads / qs.execution_count AS avg_logical_reads,

    qs.execution_count,

    SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,

        ((CASE qs.statement_end_offset

            WHEN -1 THEN DATALENGTH(qt.text)

            ELSE qs.statement_end_offset

        END - qs.statement_start_offset)/2)+1) AS statement_text

FROM sys.dm_exec_query_stats qs

CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt

WHERE qt.text LIKE '%Inout_%'

ORDER BY avg_elapsed_time DESC;

```

  

## 4. 表分区建议

```sql

-- 对于大表，考虑按时间分区

-- 创建分区函数

CREATE PARTITION FUNCTION pf_InoutByMonth (datetime)

AS RANGE RIGHT FOR VALUES

('2024-01-01', '2024-02-01', '2024-03-01', '2024-04-01',

 '2024-05-01', '2024-06-01', '2024-07-01', '2024-08-01',

 '2024-09-01', '2024-10-01', '2024-11-01', '2024-12-01');

  

-- 创建分区方案

CREATE PARTITION SCHEME ps_InoutByMonth

AS PARTITION pf_InoutByMonth

ALL TO ([PRIMARY]);

  

-- 在新表上应用分区（需要重建表）

-- CREATE TABLE dbo.Inout_1_Partitioned (

--     ... 列定义 ...

-- ) ON ps_InoutByMonth(created);

```

  

## 5. 内存优化

```sql

-- 检查缓冲池使用情况

SELECT

    OBJECT_NAME(p.object_id) AS TableName,

    i.name AS IndexName,

    COUNT(*) AS BufferPages,

    COUNT(*) * 8 / 1024 AS BufferSizeMB

FROM sys.allocation_units a

INNER JOIN sys.dm_os_buffer_descriptors b ON a.allocation_unit_id = b.allocation_unit_id

INNER JOIN sys.partitions p ON a.container_id = p.hobt_id

INNER JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id

WHERE p.object_id = OBJECT_ID('dbo.Inout_1')

GROUP BY p.object_id, i.name

ORDER BY BufferPages DESC;

  

-- 考虑启用内存优化表（SQL Server 2014+）

-- ALTER DATABASE [YourDatabase] ADD FILEGROUP [InMemory_FG] CONTAINS MEMORY_OPTIMIZED_DATA;

```

  

## 6. 监控和告警

```sql

-- 创建性能监控视图

CREATE VIEW v_InoutPerformanceMonitor AS

SELECT

    'Inout Query Performance' AS MetricName,

    COUNT(*) AS QueryCount,

    AVG(qs.total_elapsed_time / qs.execution_count) AS AvgElapsedTime,

    MAX(qs.total_elapsed_time / qs.execution_count) AS MaxElapsedTime,

    GETDATE() AS CheckTime

FROM sys.dm_exec_query_stats qs

CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt

WHERE qt.text LIKE '%Inout_%'

  AND qs.last_execution_time > DATEADD(HOUR, -1, GETDATE());

  

-- 设置性能告警阈值

-- 当平均查询时间超过 5 秒时发出告警

```

  

## 7. 应用层优化建议

  

### 连接池优化

- 合理设置连接池大小

- 使用连接池监控

- 避免长时间持有连接

  

### 查询优化

- 避免 SELECT *，只查询需要的字段

- 使用参数化查询防止 SQL 注入

- 合理使用事务，避免长事务

- 实施读写分离

  

### 缓存策略

- 对频繁查询的数据进行缓存

- 使用分布式缓存（Redis）

- 实施缓存失效策略

  

## 8. 定期维护任务

```sql

-- 创建维护计划

-- 1. 每日更新统计信息

-- 2. 每周重建碎片率高的索引

-- 3. 每月检查查询性能

-- 4. 季度性能评估和优化

```
# 调拨单业务逻辑分析文档

## 概述

本文档详细分析了G系统中调拨单(Allocation)的业务逻辑，包括自营仓调拨、货主调拨、第三方仓调拨等多种业务场景，以及分库分表架构下的数据存储和跨库访问机制。

## 目录

1. [调拨单业务概述](#调拨单业务概述)
2. [核心业务流程](#核心业务流程)
3. [TPW模式下的调拨权限](#tpw模式下的调拨权限)
4. [第三方仓代理调拨逻辑](#第三方仓代理调拨逻辑)
5. [分库分表架构](#分库分表架构)
6. [数据存储和查询机制](#数据存储和查询机制)
7. [跨库访问实现](#跨库访问实现)

---

## 调拨单业务概述

调拨单是WMS（仓库管理系统）中用于处理仓库间货物转移的核心功能，主要包含调拨出和调拨入两个环节。

### 调拨单类型
- **AllocationOut（调拨出）**: 从源仓库调出货物
- **AllocationIn（调拨入）**: 向目标仓库调入货物  
- **AllocationDiff（调拨差异）**: 处理调拨过程中的差异

### 调拨单状态流转
- **WaitConfirm（待确认）**: 调拨单创建后的初始状态
- **Confirmed（已确认）**: 调拨单确认后的状态

---

## 核心业务流程

### 1. 手动创建调拨单
```csharp
// 在 AllocationService.cs 中的 SaveAllocation 方法
public Inout SaveAllocation(Inout rqInout, bool isConfirm)
```
- 支持创建新调拨单或修改现有调拨单
- 验证调拨出入仓库不能完全相同
- 支持保存后直接确认调拨出

### 2. 自动调拨
```csharp
// 拣货时自动创建调拨单
internal void AutoAllocation(List<PickItem> items)
internal void AutoAllocation(List<MoveItem> items)
```
- 在拣货或移库操作时自动触发
- 根据工作项自动创建调拨单据

### 3. 波次调拨
```csharp
// 基于波次的调拨处理
internal WorkItemDict CreateAutoAllocation(Wave wave, List<Pack.Pack> packs)
```
- 支持将调拨单加入拣货波次
- 根据波次拣货情况自动调整调拨数量

### 4. 精细库存支持

#### 箱管理集成
- 支持精细库存的仓库需要通过拣货流程确认调拨出
- 调拨入时自动处理箱的移动和状态更新
- 箱状态包含 `PackStatus.Allocation`（调拨中）

#### 调拨入登记
```csharp
// AllocationInInput.cshtml.cs 中的验证逻辑
if (!pack.CheckStatuss(PackStatus.Allocation))
{
    throw new TException("当前箱并不处于调拨中");
}
```

### 5. 库存锁定机制
- 调拨出时锁定源仓库库存（pick_lock）
- 确认调拨时释放锁定并扣减库存
- 支持调拨单作废时自动释放锁定

---

## TPW模式下的调拨权限

### 支持的业务模式

#### 1. 自营仓调拨 ✅
**业务逻辑**:
- 自营仓库之间可以自由调拨
- 货主ID为0时表示自营货物
- 在`WarehouseService.cs`中的标识：
```csharp
public string GetOwnerName(long ownerid)
{
    if (ownerid == 0)
    {
        return T("--自营--");
    }
    // ...
}
```

#### 2. 货主调拨（TPW货主模式） ✅
**业务逻辑**:
- 系统通过`TpwPartnerService`管理货主关系
- 每个调拨单必须指定`owner_id`，确保货主一致性
- 验证逻辑：
```csharp
if (oldInout.owner_id != rqInout.owner_id)
{
    throw new TException("货主不允许修改：({0})", rqInout.io_id);
}
```

#### 3. 第三方仓调拨（TPW仓储模式） ✅
**业务逻辑**:
- 通过`tpw_id`字段标识第三方仓库
- 仓库可以绑定到具体的TPW合作伙伴
- 相关逻辑：
```csharp
public bool IsTpwWarehouse(string whid)
{
    return ExistTpwWarehouse && TpwWhids.Contains(whid);
}
```

### 调拨单操作权限

#### 货主权限
- ✅ 可以在自己委托的不同第三方仓之间调拨
- ✅ 可以从第三方仓调拨到自营仓
- ✅ 可以从自营仓调拨到第三方仓
- ❌ 不能操作其他货主的库存

#### 第三方仓权限
- ✅ 可以代表货主创建调拨单（通过API接口）
- ✅ 可以在自己管理的不同仓库间调拨
- ✅ 可以处理多个货主的调拨需求
- ⚠️ 创建的调拨单会标记`tpw_id`以区分操作来源

---

## 第三方仓代理调拨逻辑

### 代理调拨的触发场景

#### 场景A：接收货主系统的调拨指令
```csharp
/// <summary>
/// 接收下游发起的进销存单据，一般指下游单据确认生效触发
/// </summary>
internal void ReceiverConfirmFromInoutT2F(List<Inout.Inout> warehouseInouts)
```

#### 场景B：自动调拨触发
```csharp
// 在拣货或移库时自动触发调拨
internal void AutoAllocation(List<PickItem> items)
{
    AutoAllocationOut = true;
    var moves = items.Where(o => o.CheckAllocation());
    // 当源仓库和目标仓库不同时触发调拨
}

// 调拨检查条件
public bool CheckAllocation()
{
    return !from_wh_id.Is(to_wh_id) || from_sub_wh_id != to_sub_wh_id;
}
```

### 代理调拨单的创建逻辑

#### 第一步：重复性检查
```csharp
var onwerIos = LoadOwnerInouts(warehouseInouts).ToFrozenDictionary(o => o.outer_io_id);
HashSet<long> disableSaveIos = new HashSet<long>();

foreach (var warehouseInout in warehouseInouts)
{
    var outerIoid = TpwPartnerLC.partner_id + "-" + warehouseInout.io_id;
    if (onwerIos.TryGetValue(outerIoid, out var ownerIo))
    {
        // 通过HashCode比较单据内容是否变化
        if (BuildInoutHashCode(ownerIo) != BuildInoutHashCode(warehouseInout))
        {
            CheckAndCancel(ownerIo); // 取消旧单据
        }
        else
        {
            disableSaveIos.Add(warehouseInout.io_id); // 跳过重复单据
        }
    }
}
```

#### 第二步：仓库映射处理
```csharp
var fromWhid = io.GetJsonData<string>("from_wh_id");
if (fromWhid.IsNullOrEmpty())
{
    fromWhid = GetOwnerWhidByTpwWhid(io.wh_id);
}
```

#### 第三步：创建代理调拨单
```csharp
Inout.Inout newIo = new Inout.Inout();
newIo.wh_id = fromWhid;                                    // 映射后的货主仓库ID
newIo.is_outer = true;                                     // 标记为外部单据
newIo.outer_io_id = TpwPartnerLC.partner_id + "-" + io.io_id; // 外部单据ID
newIo.type = io.type;                                      // 保持单据类型
newIo.owner_id = 0;                                        // 设置为自营（在货主系统中）
newIo.tpw_id = TpwPartnerLC.partner_id;                   // 标记TPW来源
newIo.status = nameof(InoutStatus.WaitConfirm);           // 待确认状态
```

### 代理调拨的业务流程

```
第三方仓系统                    货主系统
     │                           │
     ├─ 1. 接收调拨指令 ──────────→ │
     │                           │
     ├─ 2. 验证重复性              │
     │                           │
     ├─ 3. 仓库ID映射              │
     │                           │
     ├─ 4. 创建代理调拨单 ─────────→ │ ← 5. 生成货主调拨单
     │                           │
     ├─ 6. 执行实际拣货/入库       │
     │                           │
     ├─ 7. 确认调拨完成 ──────────→ │ ← 8. 更新货主库存
     │                           │
     └─ 9. 同步库存状态            │
```

---

## 分库分表架构

### 分库分表的真实结构

#### 分库逻辑
```csharp
// 在CompanyLC.cs中
public int DbClusterId  // 数据库集群ID
{
    get
    {
        if (!IsSplitDb)
        {
            return -1;
        }
        else
        {
            return SplitDb.DbMaps.First().Value.DbId;  // 实际的分库ID
        }
    }
}

public string FormatSplitTableName(string tableName)
{
    return tableName + "_" + Jst.Data.Helper.ParseTableTeamPostfix(TableTeamId);
}
```

**实际架构**：
- `Inout_$1` 中的 `$1` 是**分库号**（如：1, 2, 3...）
- 每个分库中存储**多个公司**的数据
- 通过 `co_id` 字段区分不同公司的数据

#### 表名示例
```
数据库1: DB_Cluster_1
├── Inout_1 (包含公司100, 200, 300的调拨单)
├── Stock_1 (包含公司100, 200, 300的库存)
└── ...

数据库2: DB_Cluster_2  
├── Inout_2 (包含公司400, 500, 600的调拨单)
├── Stock_2 (包含公司400, 500, 600的库存)
└── ...
```

---

## 数据存储和查询机制

### 调拨单查询条件
```json
// 在Allocation.json中
"RequiredCondition": "co_id=@0 and wh_id=@1 and type in ('AllocationOut','AllocationIn','AllocationDiff')",
"RequiredConditionParams": [
    "$coid",    // 公司ID，用于数据隔离
    "#wh_id"    // 仓库ID
]
```

**查询流程**：
1. 根据公司ID确定分库号（通过`SplitDb.DbMaps`）
2. 连接到对应的分库
3. 在表中通过`co_id=@0`过滤出该公司的数据

### 数据存储模式

#### 双重存储机制
**货主系统存储**：
```csharp
// 货主创建的调拨单
Inout ownerAllocation = new Inout();
ownerAllocation.owner_id = 货主ID;  // 实际货主ID
ownerAllocation.wh_id = "货主仓库ID";
ownerAllocation.is_outer = false;   // 内部单据
ownerAllocation.tpw_id = null;      // 无TPW标记
```

**第三方仓存储**：
```csharp
// 第三方仓代理创建的调拨单
Inout tpwAllocation = new Inout();
tpwAllocation.owner_id = 0;                                    // 在货主系统中显示为自营
tpwAllocation.wh_id = "映射后的货主仓库ID";
tpwAllocation.is_outer = true;                                 // 外部单据标记
tpwAllocation.outer_io_id = TpwPartnerLC.partner_id + "-" + 原单据ID;  // 关联原始单据
tpwAllocation.tpw_id = TpwPartnerLC.partner_id;               // TPW来源标记
```

### 单据查询和可见性

#### 货主查看调拨单
```sql
-- 查询公司100在分库1中的调拨单
SELECT * FROM Inout_1 
WHERE co_id = 100 
  AND wh_id = '100-1' 
  AND type IN ('AllocationOut','AllocationIn','AllocationDiff')
  AND (
    (is_outer IS NULL OR is_outer = 0)  -- 自己创建的调拨单
    OR 
    (is_outer = 1 AND tpw_id IS NOT NULL)  -- 第三方仓代理创建的调拨单
  )
```

#### 第三方仓查看调拨单
```sql
-- 在第三方仓所在的分库中查询自己的单据
SELECT * FROM Inout_2 
WHERE co_id = 200  -- 第三方仓公司ID

-- 跨库查询货主系统中的对应单据
SELECT * FROM Inout_1 
WHERE co_id = 100  -- 货主公司ID
  AND tpw_id = 200  -- 自己创建的代理单据
  AND is_outer = 1
```

---

## 跨库访问实现

### MasterService跨公司操作

#### 创建跨公司MasterService
```csharp
public MasterService BindNewMasterService(int coid)
{
    MasterService masterService = new MasterService() { 
        CurrentUserContext = CurrentUserContext.NewSingle(coid)  // 切换到目标公司
    };
    
    // 关键：重新绑定数据库连接
    masterService.DbConnectionAdapter = masterService.TopMasterService.DbConnectionAdapter.BindCopy(masterService.CurrentUserContext);
    
    return masterService;
}
```

#### TPW跨公司访问
```csharp
// 第三方仓的MasterService（连接分库1）
var tpwMasterService = new MasterService();
tpwMasterService.CurrentUserContext.Coid = 200;  // 第三方仓公司ID

// 创建货主的MasterService（可能连接不同分库）
var ownerMasterService = tpwMasterService.BindNewMasterService(100);  // 货主公司ID
```

### 数据存储的真实情况

#### 情况A：货主和第三方仓在同一分库
```
分库1 (DB_Cluster_1):
├── Inout_1
│   ├── co_id=100 (货主数据)
│   │   ├── 货主自己创建的调拨单 (is_outer=null, tpw_id=null)
│   │   └── 第三方仓代理创建的调拨单 (is_outer=1, tpw_id=200)
│   └── co_id=200 (第三方仓数据)
│       └── 第三方仓自己的调拨单
└── Stock_1
    ├── co_id=100 (货主库存)
    └── co_id=200 (第三方仓库存)
```

#### 情况B：货主和第三方仓在不同分库
```
分库1 (DB_Cluster_1):
├── Inout_1
│   └── co_id=100 (货主数据)
│       ├── 货主自己创建的调拨单
│       └── 第三方仓代理创建的调拨单 (is_outer=1, tpw_id=200)
└── Stock_1
    └── co_id=100 (货主库存)

分库2 (DB_Cluster_2):  
├── Inout_2
│   └── co_id=200 (第三方仓数据)
│       └── 第三方仓自己的调拨单
└── Stock_2
    └── co_id=200 (第三方仓库存)
```

### 第三方仓代理调拨的完整流程

#### 步骤1：第三方仓创建调拨单（在自己的分库）
```csharp
// 在第三方仓的分库中创建
var tpwInout = new Inout();
tpwInout.co_id = 200;           // 第三方仓公司ID
tpwInout.owner_id = 100;        // 实际货主ID
tpwInout.wh_id = "200-warehouse"; // 第三方仓的仓库ID
// 保存到 Inout_2 表中
```

#### 步骤2：推送到货主系统（跨库操作）
```csharp
// 切换到货主的MasterService
var ownerMs = tpwMs.BindNewMasterService(100);  // 可能连接到分库1

// 在货主的分库中创建对应的调拨单
var ownerInout = new Inout();
ownerInout.co_id = 100;                                    // 货主公司ID
ownerInout.owner_id = 0;                                   // 在货主系统中显示为自营
ownerInout.is_outer = true;                                // 外部单据标记
ownerInout.outer_io_id = "200-" + tpwInout.io_id;        // 关联原始单据
ownerInout.tpw_id = 200;                                  // 第三方仓公司ID
ownerInout.wh_id = GetOwnerWhidByTpwWhid(tpwInout.wh_id); // 映射到货主仓库
// 保存到 Inout_1 表中
```

### 库存同步机制

#### 库存数据分布
- **第三方仓库存**：存储在第三方仓所在分库的`Stock_X`表中，`co_id=200`
- **货主库存**：存储在货主所在分库的`Stock_Y`表中，`co_id=100`

#### 同步机制
```csharp
// 调拨确认时的跨库库存更新
public void ConfirmAllocation(Inout allocation)
{
    if (allocation.tpw_id.HasValue)  // 第三方仓代理的调拨单
    {
        // 1. 更新货主库存（当前分库）
        StockService.UpdateStock(allocation);
        
        // 2. 切换到第三方仓的MasterService
        var tpwMs = BindNewMasterService(allocation.tpw_id.Value);
        
        // 3. 更新第三方仓的物理库存（可能在不同分库）
        tpwMs.StockService.UpdatePhysicalStock(allocation);
        
        // 4. 统一提交（WriteAll会处理跨库事务）
        WriteAll();
    }
}
```

---

## 数据一致性保障

### 1. 事务管理
```csharp
// 使用MasterService的WriteAll机制保证事务性
public void WriteAll()
{
    // 按WriteSort顺序执行所有DA的Write方法
    var sortWrite = WriteDAList.OrderBy(o => o.WriteSort);
    foreach (var s in sortWrite)
    {
        if (s is MasterService service)
        {
            service.WriteAll();  // 递归调用子MasterService
        }
        else
        {
            s.Write();
        }
    }
}
```

### 2. 防重机制
```csharp
// 通过outer_io_id和内容HashCode防止重复
private int BuildInoutHashCode(Inout.Inout inout)
{
    StringBuilder sb = new StringBuilder();
    sb.Append(inout.io_date.ToString("yyyy-MM-dd"));
    var shortItems = inout.Items.Select(o => o.sku_id + "." + o.qty).OrderBy(o => o).ToList();
    foreach (var item in shortItems)
    {
        sb.Append(item);
    }
    return sb.ToString().ToHashcode();
}
```

### 3. 数据追溯
- `outer_io_id`：关联原始单据，格式为`TPW合作伙伴ID-原单据ID`
- `tpw_id`：标识操作来源的第三方仓
- `is_outer`：区分内部单据和外部推送单据

---

## 关键字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `co_id` | int | 公司ID，用于在分库中区分不同公司的数据 |
| `owner_id` | long | 货主ID，0表示自营，>0表示第三方货主 |
| `tpw_id` | long? | 第三方仓合作伙伴ID，标识操作来源 |
| `is_outer` | bool? | 是否外部单据，true表示第三方仓推送的单据 |
| `outer_io_id` | string | 外部单据ID，格式：`TPW合作伙伴ID-原单据ID` |
| `wh_id` | string | 仓库ID |
| `link_wh_id` | string | 关联仓库ID（调拨目标仓库） |
| `type` | string | 单据类型：AllocationOut/AllocationIn/AllocationDiff |
| `status` | string | 单据状态：WaitConfirm/Confirmed |

---

## 总结

G系统的调拨单业务逻辑设计非常完善，主要特点：

1. **多模式支持**：完全支持自营仓调拨、货主调拨、第三方仓调拨
2. **权限控制**：通过`owner_id`、`tpw_id`等字段实现精细的权限控制
3. **分库架构**：采用分库分表架构，通过`co_id`实现数据隔离
4. **跨库访问**：通过MasterService的`BindNewMasterService`机制实现跨库操作
5. **数据同步**：支持第三方仓和货主系统间的实时数据同步
6. **事务保障**：通过统一的WriteAll机制确保跨库事务一致性
7. **防重机制**：通过`outer_io_id`和内容HashCode防止重复创建
8. **数据追溯**：完整的操作来源追溯和关联机制

这种架构既保证了数据的安全性和独立性，又实现了业务的协同性，是一个相当成熟的多租户B2B仓储协作解决方案。

---

**文档创建时间**：2024-12-24  
**分析对象**：G系统调拨单业务逻辑  
**涉及模块**：WMS、TPW、MasterService、分库分表架构
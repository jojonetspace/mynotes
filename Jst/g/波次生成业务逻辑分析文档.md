# 波次(Wave)生成业务逻辑分析文档

## 概述

本文档详细分析了WMS系统中波次生成的各种业务逻辑，包括一键生成、按规则生成、按订单生成、按商品生成等不同方式的实现机制和数据处理流程。

## 1. 波次生成方式概览

### 1.1 四种主要生成方式

| 生成方式          | 方法名称                         | 触发条件                   | 规则来源                         | 订单来源          | 适用场景              |
| ------------- | ---------------------------- | ---------------------- | ---------------------------- | ------------- | ----------------- |
| **一键生成**      | `QuickCreate()`              | 前端点击"一键生成波次"按钮         | 自动加载所有`quick_able=true`的启用规则 | 系统自动查询待出库订单   | 日常批量处理，快速生成多种类型波次 |
| **按规则生成**     | `RuleCreate(ruleids)`        | 前端勾选规则后点击"按勾选规则批量生成波次" | 用户手动选择的规则ID列表                | 系统自动查询待出库订单   | 有针对性的波次生成，精确控制    |
| **按订单生成**     | `CreateWave(ios)`            | 系统内部调用或API调用           | 不依赖规则，使用默认配置                 | 传入的具体订单列表     | 紧急订单处理，特殊订单单独处理   |
| **按商品生成(补货)** | `CreateWave(ReplenishItems)` | 补货模块调用                 | 使用补货规则                       | 基于库存分析生成的补货需求 | 库存补货，仓位调拨         |

### 1.2 核心文件结构

```
G/WMS/Work/Wave/
├── WaveService.cs              # 波次服务主类
├── Wave.cs                     # 波次实体类
├── WaveDA.cs                   # 波次数据访问层
├── WaveCreateGrouper.cs        # 波次生成分组器
├── WaveReplenishService.cs     # 补货波次服务
└── Rule/
    ├── WaveRule.cs             # 波次规则实体
    ├── WaveRuleService.cs      # 波次规则服务
    ├── WaveRuleDo.cs           # 规则动作配置
    └── WaveRuleWhere.cs        # 规则条件配置
```

## 2. 一键生成 vs 按规则生成详细对比

### 2.1 入口方法对比

| 方法 | 一键生成 `QuickCreate()` | 按规则生成 `RuleCreate(ruleids)` |
|------|-------------------------|--------------------------------|
| **规则加载** | `WaveRuleService.LoadRules(今天, 明天, true)` | `WaveRuleService.LoadRules(ruleids)` |
| **规则筛选** | `rule_do.quick_able = true` + 启用 + 时间范围 | 启用 + 时间范围 |
| **调用核心方法** | `RuleCreate(rules)` | `RuleCreate(rules)` |

### 2.2 核心处理流程 `RuleCreate(List<WaveRule> rules)`

#### 第一阶段：规则预处理
```csharp
// 1. 仓库过滤和排序
rules = rules.Where(o => o.rule_where.wh_id is null || o.rule_where.wh_id.Is(Whid))
             .OrderBy(o => o.sort)
             .ThenBy(o => o.RuleTypeSort)
             .ToList();

// 2. 加载待处理订单
var ios = LoadCreateWaveInouts(rules);

// 3. 二次排序（处理空sort值）
rules = rules.OrderBy(o => o.sort.HasValue ? o.sort : int.MaxValue).ToList();
```

#### 第二阶段：数据预加载
```csharp
// 1. 加载订单明细
InoutService.LoadInoutItems(ios);

// 2. 加载包装库存信息
LoadWaveCreatePacks(ios);

// 3. 设置分组器的包装字典
this.WaveCreateGrouper.LoadedPackItemDict = LoadedPackItemDict;
```

#### 第三阶段：逐规则处理
```csharp
foreach (var rule in rules)
{
    // 1. 筛选符合规则条件且未分配的订单
    var ruleIos = ios.Where(o => !o.AddedWave && WaveRuleService.RuleWhere(o, rule)).ToList();
    
    // 2. 根据波次类型进行库存过滤
    if (rule.rule_where.WaveType == WaveType.Multiple)
    {
        ruleIos = WaveRuleService.FilterMultiple(ruleIos, rule);
    }
    else if (rule.rule_where.WaveType == WaveType.Single)
    {
        ruleIos = WaveRuleService.FilterSingle(ruleIos, rule);
    }
    
    // 3. 配置分组器并执行
    this.WaveCreateGrouper.Reset();
    this.WaveCreateGrouper.WaveRule = rule;
    this.WaveCreateGrouper.RequestIos = ruleIos;
    this.WaveCreateGrouper.WaveType = rule.rule_where.WaveType;
    this.WaveCreateGrouper.Process();
}
```

#### 第四阶段：后处理
```csharp
// 1. 写入数据库获取波次ID
MasterService.WriteAll();

// 2. 处理纸质拣货波次
var pWaves = this.WaveCreateGrouper.ReturnWaves.Where(x => x.CheckPickType(WavePickType.Paper)).ToList();
foreach (var pWave in pWaves)
{
    PaperPick(pWave);
    pWave.status = WaveStatus.WaitCheck.ToString();
    this.WaveModifyBufferList.Add(pWave);
    MasterService.WriteAll();
}
```

### 2.3 订单加载逻辑 `LoadCreateWaveInouts(rules)`

#### 基础查询条件
```sql
SELECT * FROM Inout 
WHERE co_id = @0 
  AND wh_id = @1 
  AND type = 'OrderOut' 
  AND w_id = 0 
  AND status = 'WaitConfirm'
```

#### 智能优化查询
| 规则类型组合 | 附加查询条件 | 优化目的 |
|-------------|-------------|----------|
| 仅Single规则 | `AND skus LIKE '1=%'` | 只查询单件订单 |
| 仅Multiple规则(无qty=1) | `AND NOT skus LIKE '1=%'` | 只查询多件订单 |
| 混合规则 | 无附加条件 | 查询所有订单 |

## 3. 波次类型和生成策略

### 3.1 Single (单件波次)
- **特点**: 每个订单只有1件商品
- **生成逻辑** (`WaveCreateGrouper.CreateSingleWaves()`):
  - 按相同SKU分组
  - 支持路径优化排序
  - 可配置最大、最小订单数量
  - 优先处理达到数量要求的同SKU订单

### 3.2 Multiple (多件波次)
- **特点**: 订单包含多件商品
- **生成逻辑** (`WaveCreateGrouper.CreateMultipleWaves()`):
  - **四阶段聚集算法**:
    1. **相同区域汇总**: 按拣货区域完全相同分组
    2. **向下汇总**: 寻找包含关系的区域组合
    3. **向上汇总**: 寻找被包含关系的区域组合  
    4. **无汇总**: 按仓位排序直接分组

### 3.3 Group (组团波次)
- **特点**: 按相同SKU组合分组
- **生成逻辑** (`WaveCreateGrouper.CreateGroupWaves()`):
  - 按订单的SKU组合 (`skus`) 分组
  - 每组必须达到最小订单数量要求
  - 超过最大数量时平均拆分

### 3.4 特殊波次类型
- **AutoAllocation**: 自由调拨波次
- **Allocation**: 调拨波次  
- **OrderReplenish/NormalReplenish**: 补货波次

## 4. 波次规则系统

### 4.1 规则条件 (WaveRuleWhere)
```csharp
// 基础条件
- wh_id: 仓库限制
- wave_type: 波次类型
- min_amount/max_amount: 订单金额范围
- min_qty/max_qty: 商品数量范围
- min_item_count/max_item_count: 商品种类数量
- min_sku_count/max_sku_count: SKU数量范围

// 商品条件  
- sku_ids/no_sku_ids: 包含/排除的SKU
- i_ids/no_i_ids: 包含/排除的商品ID
- shop_ids: 店铺限制
- owner_ids: 货主限制
- lc_ids: 物流公司限制

// 仓位条件
- from_bins/to_bins: 源仓位/目标仓位限制
```

### 4.2 规则动作 (WaveRuleDo)
```csharp
- min_io_count/max_io_count: 订单数量范围
- io_count: 固定订单数量
- sku_count: SKU数量限制
- pick_type: 拣货方式 (Pda/Paper)
- seed_type: 播种方式
- check_stock: 是否检查库存
- quick_able: 是否支持一键生成
- bin_qty_rate: 仓位数量比例
```

## 5. 库存检查机制

### 5.1 双重库存管理体系

#### **PackItemDict（仓位库存字典）**
- **数据来源**: `PackService.LoadWaveCreateItems(whid, skuids)`
- **存储结构**: `Dictionary<string, List<PackItem>>` - 按 `{whid}.{sku_id}.{owner_id}` 为键
- **数据内容**: 
  ```csharp
  // 启用包装管理的仓库
  SELECT ti.sku_id, ti.owner_id, ti.qty, ti.pack_id, t.bin, t.type 
  FROM Pack t JOIN Pack_Item ti ON t.pack_id = ti.pack_id 
  WHERE t.type = 'bin' AND t.sub_wh_id = 0 AND ti.qty > 0
  
  // 未启用包装管理的仓库
  // 通过StockService加载库存，然后转换为PackItem格式
  ```
- **用途**: 
  - 为订单计算拣货仓位分组 (`GroupBin`)
  - 提供仓位路径优化的基础数据
  - 在`WaveCreateGrouper`中用于仓位排序

#### **WaveCreateStockDict（波次生成库存字典）**
- **数据来源**: 基于`PackItemDict`构建的内存库存管理
- **存储结构**: `Dictionary<string, Stock>` - 按 `{whid}.{sku_id}.{owner_id}` 为键
- **核心属性**:
  ```csharp
  public class Stock {
      public decimal qty;           // 实际库存数量
      public decimal TempQty;       // 临时扣减数量
      public decimal BufferQty;     // 缓冲扣减数量
      
      // 波次生成时的库存检查
      internal bool WaveEnable(decimal qty) {
          return this.qty - TempQty - BufferQty >= qty;
      }
  }
  ```

### 5.2 库存扣减流程详解

#### **第一阶段：初始化库存字典**
```csharp
// 1. 加载仓位库存数据
var packItems = PackService.LoadWaveCreateItems(Whid, skuids);
LoadedPackItemDict = new(packItems);

// 2. 构建库存字典
WaveCreateStockDict = new StockDict();
foreach (var pi in packItems) {
    var stock = WaveCreateStockDict[Whid, pi, pi.owner_id];
    stock.qty += pi.qty;  // 累加实际库存
}

// 3. 扣减待拣波次占用的库存
var waitPicks = LoadWaitPickItems(skuids);
foreach (var item in waitPicks) {
    var stock = WaveCreateStockDict[Whid, item, item.owner_id];
    stock.qty -= item.qty;  // 扣减已分配但未拣货的数量
}
```

#### **第二阶段：规则处理中的库存检查**

##### **Single波次库存检查** (`FilterSingle`)
```csharp
return ios.Where(io => {
    WaveCreateStockDict.ClearBufferQty();  // 清空缓冲区
    bool isStockAble = true;
    
    foreach (var item in io.PickableItems) {
        var qty = item.FQty * -1;
        var stock = WaveCreateStockDict[io.wh_id, item, io.GetItemOwnerId(item)];
        
        if (!stock.WaveEnable(qty)) {  // 检查: qty - TempQty - BufferQty >= qty
            WaveService.AddStockOut(item.sku_id, qty);
            isStockAble = false;
        } else {
            stock.BufferQty += qty;  // 暂存到缓冲区
        }
    }
    
    if (isStockAble) {
        WaveCreateStockDict.BufferQtyToTempQty();  // 缓冲区 -> 临时扣减
    }
    return isStockAble;
}).ToList();
```

##### **Multiple波次库存检查** (`FilterMultiple`)
```csharp
// 逐个订单检查库存
ios = ios.Where(o => FilterWaveMultipleStock(rule, o)).ToList();

private bool FilterWaveMultipleStock(WaveRule rule, Inout.Inout io) {
    WaveCreateStockDict.ClearBufferQty();
    bool isStockAble = true;
    
    foreach (var item in io.PickableItems) {
        var qty = item.FQty * -1;
        var stock = WaveCreateStockDict[io.wh_id, item, io.GetItemOwnerId(item)];
        
        if (!stock.WaveEnable(qty)) {
            WaveService.AddStockOut(item.sku_id, qty);
            isStockAble = false;
        } else {
            stock.BufferQty += qty;
        }
    }
    
    if (isStockAble) {
        WaveCreateStockDict.BufferQtyToTempQty();  // 确认扣减
    }
    return isStockAble;
}
```

##### **Group波次库存检查** (`FilterWaveGroupStock`)
```csharp
WaveCreateStockDict.ClearTempQty();  // 清空临时扣减
List<Inout.Inout> rvIos = new List<Inout.Inout>();

foreach (var io in ios) {
    WaveCreateStockDict.ClearBufferQty();
    bool isStockAble = true;
    
    foreach (var item in io.PickableItems) {
        var stock = WaveCreateStockDict[io.wh_id, item, io.GetItemOwnerId(item)];
        if (!stock.WaveEnable(item.FQty * -1)) {
            isStockAble = false;
        } else {
            stock.BufferQty += item.FQty * -1;
        }
    }
    
    if (!isStockAble) {
        WaveCreateStockDict.ClearBufferQty();
        WaveCreateStockDict.ClearTempQty();
        return rvIos;  // 整组失败，返回已处理的订单
    }
    
    WaveCreateStockDict.BufferQtyToTempQty();
    rvIos.Add(io);
}
```

#### **第三阶段：波次创建后的最终扣减**
```csharp
// 在WaveCreateGrouper.CreateAndAddWave中
if (WaveRule.rule_do.check_stock && WaveService.WaveCreateStockDict != null) {
    WaveService.WaveCreateStockDict.MinusQty(ios);  // 最终扣减实际库存
}

// MinusQty实现
internal void MinusQty(IEnumerable<Inout> ios) {
    foreach (var io in ios) {
        foreach (var item in io.PickableItems) {
            var stock = this[io.wh_id, item, io.GetItemOwnerId(item)];
            stock.qty -= item.FQty * -1;  // 从实际库存中扣减
        }
    }
}
```

### 5.3 库存状态管理

#### **三级库存状态**
```csharp
public class Stock {
    public decimal qty;        // 实际可用库存
    public decimal TempQty;    // 临时扣减（规则处理过程中）
    public decimal BufferQty;  // 缓冲扣减（单个订单检查时）
    
    // 可用性检查
    internal bool WaveEnable(decimal needQty) {
        return qty - TempQty - BufferQty >= needQty;
    }
}
```

#### **状态转换方法**
```csharp
// 清空缓冲区
public void ClearBufferQty() {
    foreach (var stock in this) {
        stock.Value.BufferQty = 0;
    }
}

// 缓冲区 -> 临时扣减
internal void BufferQtyToTempQty() {
    foreach (var stock in this) {
        if (stock.Value.BufferQty != 0) {
            stock.Value.TempQty += stock.Value.BufferQty;
            stock.Value.BufferQty = 0;
        }
    }
}

// 临时扣减 -> 实际扣减
internal void TempQtyToQty() {
    foreach (var stock in this) {
        if (stock.Value.TempQty != 0) {
            stock.Value.qty -= stock.Value.TempQty;
            stock.Value.TempQty = 0;
        }
    }
}
```

### 5.4 不同波次类型的库存检查策略

| 波次类型 | 检查策略 | 失败处理 | 扣减时机 |
|---------|---------|---------|---------|
| **Single** | 逐个订单检查，通过则暂存到BufferQty | 跳过该订单，继续处理其他订单 | 订单检查通过后立即转为TempQty |
| **Multiple** | 逐个订单检查，通过则暂存到BufferQty | 跳过该订单，继续处理其他订单 | 订单检查通过后立即转为TempQty |
| **Group** | 按组检查，组内所有订单必须都通过 | 整组失败，清空所有临时扣减 | 整组通过后批量转为TempQty |

### 5.5 库存不足处理

#### **库存不足记录**
```csharp
// 记录库存不足的商品和数量
public Dictionary<string, decimal> StockOutDict = new(StringComparer.OrdinalIgnoreCase);

internal void AddStockOut(string skuid, decimal qty) {
    if (StockOutDict.TryGetValue(skuid, out var outStock)) {
        StockOutDict[skuid] = outStock + qty;
    } else {
        StockOutDict[skuid] = qty;
    }
}

// 生成完成后输出库存不足信息
private void WriteClientLog() {
    if (StockOutDict.Count > 0) {
        MasterService.AddClientLog(T("有以下商品仓位库存不足") + "：");
        foreach (var stock in StockOutDict) {
            MasterService.AddClientLog(stock.Key + "=" + stock.Value.ToString("#.###"));
        }
    }
}
```

## 6. PackItemDict与仓位优化算法

### 6.1 PackItemDict的作用机制

#### **数据结构**
```csharp
public class PackItemDict : ItemDictBase<List<PackItem>> {
    // 键格式: "{whid}.{sku_id}.{owner_id}"
    // 值: 该SKU在各个仓位的库存明细列表
}

public class PackItem {
    public string sku_id;      // 商品SKU
    public string pack_id;     // 箱号（对应仓位）
    public decimal qty;        // 库存数量
    public long owner_id;      // 货主ID
    public string bin;         // 仓位编码（通过关联查询获得）
    
    // 仓位分组相关
    internal WaveGroupBinType GroupBinType;  // 分组类型
    internal string GroupBin;                // 计算后的分组仓位
}
```

#### **加载逻辑**
```csharp
private void LoadWaveCreatePacks(List<Inout.Inout> ios) {
    // 1. 提取所有需要的SKU
    var skuids = InoutService.JoinPickableItems(ios)
                            .GroupToDictionary(o => o.sku_id)
                            .Keys.ToList();

    // 2. 加载仓位库存数据
    var packItems = PackService.LoadWaveCreateItems(Whid, skuids);
    LoadedPackItemDict = new(packItems);

    // 3. 为每个订单计算仓位分组
    foreach (var io in ios) {
        GroupBin(io, LoadedPackItemDict);
    }
    
    // 4. 构建库存字典用于扣减控制
    WaveCreateStockDict = new StockDict();
    foreach (var pi in packItems) {
        var stock = WaveCreateStockDict[Whid, pi, pi.owner_id];
        stock.qty += pi.qty;
    }
}
```

### 6.2 仓位分组计算 (`GroupBin`)

#### **分组算法**
```csharp
protected void GroupBin(Inout.Inout io, PackItemDict packItemDict) {
    var groupBin = CalcGroupBin(io, packItemDict);
    io.GroupBin = groupBin;
    io.GroupBinText = string.Join(",", groupBin);
}

protected List<string> CalcGroupBin(Inout.Inout io, PackItemDict packItemDict) {
    return io.Items.Select(o => {
        var pis = packItemDict[o.sku_id, io.owner_id];
        if (pis.IsNullOrEmpty()) {
            return string.Empty;
        }
        
        var pi = pis.FirstOrDefault();
        pi.GroupBinType = GroupBinType;  // Row/Area/Bin
        return pi.GroupBin;  // 根据GroupBinType计算分组仓位
    }).Distinct().OrderBy(o => o).ToList();
}
```

#### **仓位分组类型**
```csharp
public enum WaveGroupBinType {
    Row,    // 按行分组: "A" (取仓位编码的第一部分)
    Area,   // 按区域分组: "A-1" (取仓位编码的前两部分) 
    Bin     // 按具体仓位: "A-1-01" (完整仓位编码)
}

// PackItem中的GroupBin计算
internal string GroupBin {
    get {
        if (_GroupBin == null) {
            var bin = TryGetValue<string>("bin", "");
            if (bin.IsNullOrEmpty()) {
                _GroupBin = bin;
            } else {
                var bins = bin.Split('-');
                if (GroupBinType == WaveGroupBinType.Zone || bins.Length == 1) {
                    _GroupBin = bins[0];           // "A"
                } else {
                    _GroupBin = bins[0] + '-' + bins[1];  // "A-1"
                }
            }
        }
        return _GroupBin;
    }
}
```

### 6.3 Multiple波次的仓位聚集算法

#### **四阶段聚集策略**

##### **第一阶段：相同区域汇总**
```csharp
private void CalcGroupMultipleWaves1() {
    // 按完全相同的仓位分组文本分组
    var group1 = RequestIos.GroupBy(o => o.GroupBinText)
                          .OrderByDescending(o => o.Count())
                          .ToDictionary(o => o.Key, o => o.ToList());

    foreach (var kv in group1) {
        var ios = kv.Value;
        if (ios.Count >= Count && Count > 0) {
            CalcGroupBinSort(ios);  // 计算仓位排序
            ios = ReOrderByIos(ios);  // 按仓位顺序重排

            // 按固定数量分组创建波次
            int i = 0;
            while (i * Count < ios.Count) {
                var groupIos = ios.Skip(i * Count).Take(Count).ToList();
                CreateAndAddWave(groupIos);
                i++;
            }
        }
    }
}
```

##### **第二阶段：向下汇总（包含关系）**
```csharp
private void CalcGroupMultipleWaves2() {
    var group1 = GroupRequestIos(RequestIos);

    foreach (var kv in group1) {
        var ios = kv.Value.ToList();
        
        // 寻找包含当前分组的更大分组
        var like1s = group1.Where(o => !kv.Key.Equals(o.Key) && 
                                      ContrainGroupBin(kv.Key, o.Key))
                          .OrderBy(o => o.Value.Count)
                          .ToDictionary();

        foreach (var like1 in like1s) {
            ios.AddRange(like1.Value);
            ios = ReOrderByIos(ios);

            if (ios.Count >= Count) {
                var groupIos = ios.Take(Count).ToList();
                CreateAndAddWave(groupIos);
                break;
            }
        }
    }
}
```

##### **第三阶段：向上汇总（被包含关系）**
```csharp
private void CalcGroupMultipleWaves3() {
    var group1 = GroupRequestIos(RequestIos);

    foreach (var kv in group1) {
        var ios = kv.Value.ToList();
        
        // 寻找被当前分组包含的更小分组
        var like1s = group1.Where(o => !kv.Key.Equals(o.Key) && 
                                      ContrainGroupBin(o.Key, kv.Key))
                          .OrderBy(o => o.Key.Split(',').Length)
                          .ToDictionary();

        foreach (var like1 in like1s) {
            ios.AddRange(like1.Value);
            ios = ReOrderByIos(ios);

            if (ios.Count >= Count) {
                var groupIos = ios.Take(Count).ToList();
                CreateAndAddWave(groupIos);
                break;
            }
        }
    }
}
```

##### **第四阶段：无汇总（直接分组）**
```csharp
private void CalcGroupMultipleWaves4() {
    CalcGroupBinSort(RequestIos);
    RequestIos = ReOrderByIos(RequestIos);
    
    int i = 0;
    while (i * Count < RequestIos.Count) {
        var groupIos = RequestIos.Skip(i * Count).Take(Count).ToList();
        if (groupIos.Count >= MinCount) {
            CreateAndAddWave(groupIos);
        }
        i++;
    }
}
```

### 6.4 仓位排序优化 (`CalcGroupBinSort`)

#### **排序算法详解**
```csharp
protected void CalcGroupBinSort(List<Inout.Inout> ios) {
    // 1. 统计SKU在订单中的出现频次
    Dictionary<string, int> skuCount = new Dictionary<string, int>();
    foreach (var io in ios) {
        foreach (var item in io.Items) {
            var key = InoutService.BuildItemKey(io, item);
            skuCount[key] = skuCount.GetValueOrDefault(key, 0) + 1;
        }
    }

    // 2. 为每个订单计算仓位排序值
    foreach (var io in ios) {
        SortedSet<string> itemSorts = new SortedSet<string>();
        var items = InoutService.GroupInoutItems(io, false);

        foreach (var item in items) {
            var skuKey = InoutService.BuildItemKey(io, item);
            var priority = 100000 - skuCount[skuKey];  // 频次越高优先级越高

            var tmpPackItems = LoadedPackItemDict[item.sku_id, io.owner_id];
            if (tmpPackItems != null) {
                var bin = tmpPackItems.FirstOrDefault().TryGetValue<string>("bin");
                var binSort = priority.ToString().PadLeft(10, '0') + 
                             BinSortService.SortBin(bin) + "." + item.sku_id;
                itemSorts.Add(binSort);
            }
        }

        io.BinSort = itemSorts.FirstOrDefault();  // 取最优仓位排序
    }
}
```

#### **排序逻辑分析**

##### **第一步：SKU频次统计**
- **目的**: 统计每个SKU在所有订单中出现的次数
- **逻辑**: 出现频次越高的SKU，拣货优先级越高
- **BuildItemKey**: 通常格式为 `{owner_id}_{sku_id}_{pb_id}`

##### **第二步：优先级计算**
- **公式**: `priority = 100000 - skuCount[skuKey]`
- **逻辑**: 频次越高，priority数值越小，排序越靠前
- **填充**: 使用`PadLeft(10, '0')`确保数字排序正确

##### **第三步：仓位排序值构建**
- **格式**: `{priority}{BinSort}.{sku_id}`
- **BinSort**: 由`BinSortService.SortBin(bin)`计算的仓位物理排序
- **最终排序**: 先按优先级，再按仓位物理位置，最后按SKU

#### **完整排序示例**

假设有以下订单和库存数据：

##### **订单数据**
```
订单1: SKU-A(仓位A-1-01), SKU-B(仓位B-2-03)
订单2: SKU-A(仓位A-1-01), SKU-C(仓位C-3-05)  
订单3: SKU-B(仓位B-2-03), SKU-D(仓位A-2-02)
订单4: SKU-A(仓位A-1-01), SKU-E(仓位D-1-01)
订单5: SKU-C(仓位C-3-05), SKU-F(仓位B-1-04)
```

##### **第一步：频次统计**
```
skuCount = {
    "0_SKU-A_": 3,  // 出现在订单1,2,4
    "0_SKU-B_": 2,  // 出现在订单1,3  
    "0_SKU-C_": 2,  // 出现在订单2,5
    "0_SKU-D_": 1,  // 出现在订单3
    "0_SKU-E_": 1,  // 出现在订单4
    "0_SKU-F_": 1   // 出现在订单5
}
```

##### **第二步：优先级计算**
```
SKU-A: priority = 100000 - 3 = 99997
SKU-B: priority = 100000 - 2 = 99998  
SKU-C: priority = 100000 - 2 = 99998
SKU-D: priority = 100000 - 1 = 99999
SKU-E: priority = 100000 - 1 = 99999
SKU-F: priority = 100000 - 1 = 99999
```

##### **第三步：仓位物理排序**
假设`BinSortService.SortBin()`返回值：
```
A-1-01 -> "A01001"  // A区1排1号
A-2-02 -> "A02002"  // A区2排2号  
B-1-04 -> "B01004"  // B区1排4号
B-2-03 -> "B02003"  // B区2排3号
C-3-05 -> "C03005"  // C区3排5号
D-1-01 -> "D01001"  // D区1排1号
```

##### **第四步：最终排序值计算**
```
订单1商品排序值：
- SKU-A: "0000099997A01001.SKU-A"
- SKU-B: "0000099998B02003.SKU-B"
订单1.BinSort = "0000099997A01001.SKU-A" (取最小值)

订单2商品排序值：
- SKU-A: "0000099997A01001.SKU-A"  
- SKU-C: "0000099998C03005.SKU-C"
订单2.BinSort = "0000099997A01001.SKU-A"

订单3商品排序值：
- SKU-B: "0000099998B02003.SKU-B"
- SKU-D: "0000099999A02002.SKU-D"  
订单3.BinSort = "0000099998B02003.SKU-B"

订单4商品排序值：
- SKU-A: "0000099997A01001.SKU-A"
- SKU-E: "0000099999D01001.SKU-E"
订单4.BinSort = "0000099997A01001.SKU-A"

订单5商品排序值：
- SKU-C: "0000099998C03005.SKU-C"
- SKU-F: "0000099999B01004.SKU-F"
订单5.BinSort = "0000099998C03005.SKU-C"
```

##### **第五步：订单最终排序**
按`io.BinSort`排序后的订单顺序：
```
1. 订单1: "0000099997A01001.SKU-A" (SKU-A频次最高+A-1-01位置最前)
2. 订单2: "0000099997A01001.SKU-A" (同样是SKU-A+A-1-01)  
3. 订单4: "0000099997A01001.SKU-A" (同样是SKU-A+A-1-01)
4. 订单3: "0000099998B02003.SKU-B" (SKU-B频次次高+B-2-03位置)
5. 订单5: "0000099998C03005.SKU-C" (SKU-C频次次高+C-3-05位置)
```

#### **排序优化效果**

##### **拣货路径优化**
- **频次优先**: SKU-A出现3次，优先拣货可减少重复路径
- **仓位聚集**: 相同仓位的订单排在一起，减少拣货员移动距离
- **区域集中**: A区订单优先处理，然后是B区、C区

##### **效率提升**
- **减少拣货时间**: 高频SKU优先处理，避免重复往返
- **降低出错率**: 相似仓位集中处理，减少拣货员混淆
- **提高吞吐量**: 优化的拣货顺序提升整体作业效率

#### **关键设计思想**

1. **频次驱动**: 优先处理高频商品，最大化路径复用
2. **仓位聚集**: 相同或相近仓位的订单集中处理
3. **字符串排序**: 通过构造排序字符串，实现复合排序逻辑
4. **最优选择**: 每个订单取最优商品的排序值作为订单排序依据
```

### 6.5 仓位包含关系判断

#### **包含关系算法**
```csharp
protected bool ContrainGroupBin(string groupBins, string groupBin) {
    if (groupBins.IsNullOrEmpty() || groupBin.IsNullOrEmpty()) {
        return false;
    }
    
    // 完全相同 或 groupBins包含groupBin
    return groupBins == groupBin || 
           groupBins.Split(',').Contains(groupBin);
}

// 示例：
// ContrainGroupBin("A-1,A-2", "A-1") = true   // A-1,A-2 包含 A-1
// ContrainGroupBin("A-1", "A-1,A-2") = false  // A-1 不包含 A-1,A-2
// ContrainGroupBin("A-1,A-2", "A-1,A-2") = true  // 完全相同
```

### 6.6 PackItemDict在不同场景中的应用

#### **订单仓位分组**
- 为每个订单计算涉及的仓位区域
- 生成`GroupBin`和`GroupBinText`用于后续聚集

#### **库存可用性检查**
- 转换为`WaveCreateStockDict`进行库存扣减管理
- 支持三级库存状态（实际/临时/缓冲）

#### **拣货路径优化**
- 提供仓位信息用于`BinSortService.SortBin()`计算
- 支持按仓位距离和拣货频次优化排序

#### **波次分组决策**
- Multiple波次的四阶段聚集算法核心数据源
- 支持从细粒度到粗粒度的仓位聚集策略

### 6.7 性能优化考虑

#### **数据加载优化**
- 只加载涉及SKU的仓位库存数据
- 支持启用/未启用包装管理的仓库差异化处理

#### **内存管理**
- 使用字典结构快速查找
- 避免重复计算仓位分组信息

#### **算法复杂度**
- 仓位聚集算法最多执行200次递归防止死循环
- 使用排序集合优化仓位排序计算

## 7. 补货波次特殊逻辑

### 7.1 补货类型
- **OrderReplenish**: 订单补货 - 基于订单需求补货到拣货位
- **NormalReplenish**: 常规补货 - 基于库存策略补货

### 7.2 补货计算逻辑
```csharp
// 订单补货计算
decimal planQty = Math.Min(order_qty - bin_qty, pack_qty);
if (bin_max_qty != null)
{
    var maxQty = bin_max_qty.Value * RuleBinMaxRate;
    if (maxQty < planQty + bin_qty)
    {
        planQty = maxQty - bin_qty;
    }
}
item.plan_qty = Math.Max(0, planQty);
```

## 8. 前端交互逻辑

### 8.1 前端操作映射
| 操作类型 | 前端调用 | 后端方法 | 参数 |
|---------|---------|---------|------|
| 一键生成 | `$cp("QuickCreate")` | `QuickCreate()` | 无参数 |
| 规则生成 | `$cp("RuleCreate")` | `RuleCreate(ruleids)` | 规则ID数组 |
| 单规则执行 | `$cp("RuleCreate")` | `RuleCreate(ruleids)` | 单个规则ID |
| 补货生成 | 补货界面调用 | `CreateWave(ReplenishItems)` | 补货商品列表 |

### 8.2 前端支持的操作
- **一键生成**: 调用所有快速生成规则
- **按勾选规则批量生成**: 选择特定规则执行
- **编辑波次规则**: 配置生成规则
- **波次发货**: 直接按波次发货
- **查看商品/日志**: 波次详情查看

## 9. 数据流转图

```
一键生成流程：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 加载快速规则 │ -> │ 筛选启用规则  │ -> │ 调用核心方法 │
└─────────────┘    └──────────────┘    └─────────────┘

按规则生成流程：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 加载指定规则 │ -> │ 筛选启用规则  │ -> │ 调用核心方法 │
└─────────────┘    └──────────────┘    └─────────────┘

核心处理流程：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 规则预处理   │ -> │ 数据预加载    │ -> │ 逐规则处理   │
└─────────────┘    └──────────────┘    └─────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 仓库过滤排序 │    │ 订单+明细加载 │    │ 订单筛选分组 │
│ 订单智能查询 │    │ 库存信息加载  │    │ 波次生成     │
└─────────────┘    └──────────────┘    └─────────────┘

详细数据预加载流程：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│LoadInoutItems│ -> │LoadWaveCreate│ -> │构建库存字典  │
│ 加载订单明细  │    │Packs加载仓位 │    │WaveCreateStock│
└─────────────┘    └──────────────┘    └─────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 订单商品信息 │    │PackItemDict  │    │ 内存库存管理 │
│ 数量、规格等 │    │仓位库存字典   │    │ 三级扣减控制 │
└─────────────┘    └──────────────┘    └─────────────┘
                          │
                          ▼
                   ┌──────────────┐
                   │ GroupBin计算  │
                   │ 订单仓位分组  │
                   └──────────────┘

库存扣减流程：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 实际库存qty  │ -> │ 临时扣减     │ -> │ 最终扣减     │
│PackItem数据  │    │TempQty控制   │    │MinusQty执行 │
└─────────────┘    └──────────────┘    └─────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 待拣波次扣减 │    │ 缓冲区管理    │    │ 波次创建完成 │
│LoadWaitPick │    │BufferQty暂存 │    │ 库存已分配  │
└─────────────┘    └──────────────┘    └─────────────┘

仓位优化流程：
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│PackItemDict │ -> │ 仓位分组计算  │ -> │ 路径聚集优化 │
│ 仓位库存数据 │    │GroupBin/Text │    │Multiple算法 │
└─────────────┘    └──────────────┘    └─────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│ 仓位编码解析 │    │ 订单区域标记  │    │ 四阶段聚集   │
│Row/Area/Bin │    │ 拣货路径计算  │    │ 波次分组生成 │
└─────────────┘    └──────────────┘    └─────────────┘
```

## 10. 核心流程总结

1. **规则加载**: 根据仓库、时间等条件加载适用的波次规则
2. **订单筛选**: 按规则条件筛选符合要求的待出库订单
3. **库存检查**: 验证商品库存是否充足
4. **仓位计算**: 计算商品拣货仓位和路径
5. **分组生成**: 根据波次类型执行相应的分组算法
6. **波次创建**: 创建波次记录和波次商品明细
7. **订单绑定**: 将订单绑定到对应波次

## 11. 关键差异总结

| 维度 | 一键生成 | 按规则生成 | 按订单生成 | 按商品生成 |
|------|---------|-----------|-----------|-----------|
| **规则来源** | 系统自动发现 | 用户精确指定 | 不依赖规则 | 使用补货规则 |
| **订单来源** | 系统查询 | 系统查询 | 直接传入 | 库存分析 |
| **生成逻辑** | 复杂分组算法 | 复杂分组算法 | 简单聚合 | 补货计算 |
| **库存检查** | 根据规则配置 | 根据规则配置 | 可选配置 | 基于需求计算 |
| **适用场景** | 日常批量处理 | 特定需求处理 | 紧急处理 | 库存优化 |

---

**文档版本**: 1.0  
**创建时间**: 2024-12-24  
**最后更新**: 2024-12-24  
**维护人员**: 系统分析团队
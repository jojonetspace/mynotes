# 商家 10608437 慢SQL优化方案

## 文档信息
- **商家ID**: 10608437
- **分析日期**: 2025-12-15
- **分析依据**: SLS慢SQL日志 + 业务代码分析
- **问题严重程度**: 高

---

## 一、问题概述

### 1.1 慢SQL统计 (近24小时)
| 指标 | 数值 |
|------|------|
| 总慢SQL数量 | 86条 |
| 波次查询占比 | 81% (约70条) |
| 最大执行时间 | 29,026ms |
| 平均执行时间 | 8,500ms |

### 1.2 问题分类

| 问题类型 | 数量 | 最大耗时 | 优先级 |
|---------|------|---------|--------|
| 波次查询 (WaveController:GetInoutsByRuleId) | ~70 | 14,577ms | **高** |
| 订单审核INSERT (OrderController:Audit) | ~10 | 22,500ms | 中 |
| 后台任务UPDATE (OrderConvertTask) | ~8 | 29,026ms | 中 |
| 其他 | ~5 | 8,492ms | 低 |

---

## 二、核心问题分析

### 2.1 波次查询性能问题 (最高优先级)

#### 问题SQL示例
```sql
SELECT * FROM Inout_{@_ST[Combine]} i with(INDEX(IX_Inout_1_co_id_warehouse_id)) 
WHERE i.wave_id=0 
  AND i.warehouse_id=37 
  AND i.co_id=10608437 
  AND i.status IN ('Delivering','WaitChoice') 
  AND i.sku_qty<=1 AND i.sku_qty>=1 
  AND i.type = 'SaleOut' 
  AND i.pay_date>='2025/11/30 17:00:00' 
  AND i.pay_date<='2025/12/13 16:59:59' 
  AND i.link_co_id IN (11507207) 
  AND (i.label_codes not like '%SpecialOrder%') 
  AND EXISTS (SELECT 1 FROM InoutItem_{@_ST[Combine]} ii 
              WHERE ii.inout_id=i.inout_id AND ii.sku_id like '%LHLAN%')
ORDER BY pay_date
```

#### 问题根因

**问题1: SKU模糊匹配导致全表扫描**
- **代码位置**: `MTools/Jst.Global/Source/Jst.Global.Wms/DBAccess/InoutDAWaveExists.cs` 第139-143行
- **问题代码**:
```csharp
if (condition.SkuIds.Count == 1 && condition.SkuIds[0].Trim()[0] == '*')
{
    sql.Append($" AND ii.{InoutItemSchema.ColumnName.SkuId} like @{ps.Count}");
    ps.Add($"%{condition.SkuIds[0].Trim().Substring(1)}%");  // 生成 LIKE '%xxx%'
}
```
- **影响**: 当用户输入 `*LHLAN` 时，生成 `LIKE '%LHLAN%'` 查询，无法使用B-tree索引，导致InoutItem表全表扫描

**问题2: 应用层分页导致数据量过大**
- **代码位置**: `MTools/Jst.Global/Source/Jst.Global.Facade/Wms/WaveFacade.cs` 第764-793行
- **问题代码**:
```csharp
var inouts = waveCreateRule.GetAll();  // 一次性加载所有数据
// ... 应用层排序
inouts = inouts.Skip((dataPage.PageIndex - 1) * dataPage.PageSize)
               .Take(dataPage.PageSize).ToList();  // 应用层分页
```
- **影响**: 先加载全部数据到内存，再进行排序和分页，数据量大时导致内存压力和查询超时

**问题3: 强制索引提示可能不是最优**
- **代码位置**: 波次规则工厂中设置 `condition.SqlIndex`
- **问题**: 强制使用 `IX_Inout_1_co_id_warehouse_id` 索引，但该索引列顺序可能不适合当前查询条件

**问题4: EXISTS子查询嵌套过深**
- 主查询 → InoutItem子查询 → SkuLabel子查询 → PackItem子查询
- 多层嵌套导致执行计划复杂

---

## 三、优化方案

### 3.1 短期优化 (代码层面) - 预计效果: 提升50-70%

#### 优化1: 限制SKU模糊匹配方式

**修改文件**: `MTools/Jst.Global/Source/Jst.Global.Wms/DBAccess/InoutDAWaveExists.cs`

**原代码** (第139-143行):
```csharp
if (condition.SkuIds.Count == 1 && condition.SkuIds[0].Trim()[0] == '*')
{
    sql.Append($" AND ii.{InoutItemSchema.ColumnName.SkuId} like @{ps.Count}");
    ps.Add($"%{condition.SkuIds[0].Trim().Substring(1)}%");
}
```

**优化方案A - 改为后缀匹配 (推荐)**:
```csharp
if (condition.SkuIds.Count == 1 && condition.SkuIds[0].Trim()[0] == '*')
{
    var skuPattern = condition.SkuIds[0].Trim().Substring(1);
    // 改为后缀匹配，可以使用索引
    sql.Append($" AND ii.{InoutItemSchema.ColumnName.SkuId} like @{ps.Count}");
    ps.Add($"{skuPattern}%");  // 改为 'xxx%' 格式
    
    // 记录日志，便于追踪使用情况
    Jst.Log.ExceptionLogger.Log("Wave.SkuMatch", "FuzzyMatch", 
        $"CompanyId:{this.CompanyId}, Pattern:{skuPattern}%");
}
```

**优化方案B - 添加长度限制和警告**:
```csharp
if (condition.SkuIds.Count == 1 && condition.SkuIds[0].Trim()[0] == '*')
{
    var skuPattern = condition.SkuIds[0].Trim().Substring(1);
    
    // 如果模式太短，可能匹配太多数据，给出警告
    if (skuPattern.Length < 3)
    {
        throw new BusinessException("SKU模糊匹配至少需要3个字符");
    }
    
    // 限制最大返回数量
    sql.Append($" AND ii.{InoutItemSchema.ColumnName.SkuId} like @{ps.Count}");
    ps.Add($"%{skuPattern}%");
}
```

#### 优化2: 分页下推到数据库层

**修改文件**: `MTools/Jst.Global/Source/Jst.Global.Facade/Wms/WaveFacade.cs`

**原代码** (第750-793行):
```csharp
public BasePageResponse<Inout> GetInoutsByRuleId(BasePageRequest<GenerateWaveRequest> baseRequest)
{
    // ...
    var inouts = waveCreateRule.GetAll();  // 加载全部数据
    dataPage.DataCount = inouts.Count;
    // ... 应用层排序
    inouts = inouts.Skip((dataPage.PageIndex - 1) * dataPage.PageSize)
                   .Take(dataPage.PageSize).ToList();
    // ...
}
```

**优化代码**:
```csharp
public BasePageResponse<Inout> GetInoutsByRuleId(BasePageRequest<GenerateWaveRequest> baseRequest)
{
    using (var inoutService = InoutService.CreateNewService())
    {
        var request = baseRequest.RequestModel;
        var dataPage = baseRequest.DataPage;

        var getRuleResponse = WaveCreateRuleFactory.Get(request, new GenWCConditionBasicData());
        if (!getRuleResponse.Success)
        {
            return new BasePageResponse<Inout>(false, getRuleResponse.Message);
        }
        var waveCreateRule = getRuleResponse.Data;
        var condition = waveCreateRule.WaveCreateCondition;
        
        // 优化1: 先获取总数 (使用COUNT查询，不加载数据)
        var totalCount = inoutService.GetCount(condition);
        dataPage.DataCount = totalCount;
        
        // 优化2: 设置排序字段到条件中
        if (!string.IsNullOrWhiteSpace(request.OrderByField))
        {
            condition.OrderByField = request.OrderByField;
            condition.OrderByIsAsc = request.OrderByIsAsc;
        }
        
        // 优化3: 数据库层分页
        condition.PageIndex = dataPage.PageIndex;
        condition.PageSize = dataPage.PageSize;
        var inouts = inoutService.GetPage(condition);
        
        // 设置货主信息
        var companyFacade = new LinkCompanyInfoFacade(inoutService);
        var companys = companyFacade.GetCompanyName(inouts.Select(x => x.LinkCoId).Distinct().ToList());
        inouts.ForEach(x =>
        {
            if (companys.ContainsKey(x.LinkCoId))
            {
                x.LinkCompany = companys[x.LinkCoId];
            }
        });
        
        return new BasePageResponse<Inout>(inouts, dataPage);
    }
}
```

**新增方法** (InoutService.cs):
```csharp
public int GetCount(WaveCreateCondition condition)
{
    return this.InoutDA.GetCount(condition);
}

public List<Inout> GetPage(WaveCreateCondition condition)
{
    return this.InoutDA.GetPage(condition);
}
```

**新增方法** (InoutDA.cs):
```csharp
public int GetCount(WaveCreateCondition condition)
{
    var sql = new StringBuilder();
    sql.Append($"SELECT COUNT(1) FROM {InoutSchema.Singleton.GetTableNameForSql()} i {condition.SqlIndex}");
    sql.Append(GetConditionSqlExists(condition, out var ps));
    
    var result = this.ExecuteScalar(sql.ToString(), ps.ToArray());
    return Convert.ToInt32(result);
}

public List<Inout> GetPage(WaveCreateCondition condition)
{
    var sql = new StringBuilder();
    sql.Append($"SELECT * FROM {InoutSchema.Singleton.GetTableNameForSql()} i {condition.SqlIndex}");
    sql.Append(GetConditionSqlExists(condition, out var ps));
    
    // 排序
    var orderBy = "pay_date";
    if (!string.IsNullOrWhiteSpace(condition.OrderByField))
    {
        orderBy = condition.OrderByField;
        if (!condition.OrderByIsAsc)
        {
            orderBy += " DESC";
        }
    }
    sql.Append($" ORDER BY {orderBy}");
    
    // 分页 (SQL Server 2012+)
    sql.Append($" OFFSET @{ps.Count} ROWS FETCH NEXT @{ps.Count + 1} ROWS ONLY");
    ps.Add((condition.PageIndex - 1) * condition.PageSize);
    ps.Add(condition.PageSize);
    
    this.TimeOut = 300;
    var ldRows = this.Execute(sql.ToString(), ps.ToArray());
    return ldRows.Select(x => new Inout(x)).ToList();
}
```

#### 优化3: 移除或动态选择索引提示

**修改建议**:
```csharp
// 方案1: 完全移除强制索引，让SQL Server自动选择
condition.SqlIndex = string.Empty;

// 方案2: 根据查询条件动态选择索引
if (condition.BeginPayTime.HasValue || condition.EndPayTime.HasValue)
{
    // 如果有pay_date条件，使用包含pay_date的索引
    condition.SqlIndex = "with(INDEX(IX_Inout_pay_date))";
}
else
{
    // 否则使用默认索引或不指定
    condition.SqlIndex = string.Empty;
}
```

### 3.2 中期优化 (索引层面) - 预计效果: 提升30-50%

#### 优化4: 添加针对波次查询的复合索引

```sql
-- Inout表: 优化波次查询
-- 索引列顺序按照查询条件的选择性排列
CREATE NONCLUSTERED INDEX IX_Inout_wave_query 
ON Inout_1 (co_id, warehouse_id, wave_id, status, type, pay_date)
INCLUDE (sku_qty, link_co_id, label_codes, skus, order_id, logistics_company);

-- 如果上面的索引太大，可以创建更精简的版本
CREATE NONCLUSTERED INDEX IX_Inout_wave_query_lite 
ON Inout_1 (co_id, warehouse_id, wave_id, status, type)
INCLUDE (pay_date, sku_qty, link_co_id);
```

#### 优化5: 考虑为SKU模糊查询创建全文索引

```sql
-- 如果SKU模糊查询非常频繁，考虑全文索引
-- 注意: 全文索引需要额外的维护成本

-- 1. 创建全文目录
CREATE FULLTEXT CATALOG FT_InoutItem AS DEFAULT;

-- 2. 创建全文索引
CREATE FULLTEXT INDEX ON InoutItem_1 (sku_id)
KEY INDEX PK_InoutItem_1
ON FT_InoutItem;

-- 3. 修改查询代码使用CONTAINS
-- 原: WHERE sku_id LIKE '%LHLAN%'
-- 新: WHERE CONTAINS(sku_id, '*LHLAN*')
```

### 3.3 长期优化 (架构层面)

#### 优化6: 引入缓存层

```csharp
// 缓存常用的波次规则配置
public class WaveRuleCacheService
{
    private readonly IDistributedCache _cache;
    private readonly TimeSpan _cacheExpiry = TimeSpan.FromMinutes(5);
    
    public async Task<List<Inout>> GetInoutsByRuleIdCached(
        int companyId, 
        long warehouseId, 
        string ruleId,
        Func<Task<List<Inout>>> dataLoader)
    {
        var cacheKey = $"wave:inouts:{companyId}:{warehouseId}:{ruleId}";
        
        var cached = await _cache.GetStringAsync(cacheKey);
        if (!string.IsNullOrEmpty(cached))
        {
            return JsonSerializer.Deserialize<List<Inout>>(cached);
        }
        
        var data = await dataLoader();
        
        // 只缓存数据量较小的结果
        if (data.Count <= 1000)
        {
            await _cache.SetStringAsync(cacheKey, 
                JsonSerializer.Serialize(data), 
                new DistributedCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = _cacheExpiry
                });
        }
        
        return data;
    }
}
```

#### 优化7: 异步预计算

```csharp
// 定时任务预计算波次匹配结果
public class WavePrecomputeTask : IJob
{
    public async Task Execute(IJobExecutionContext context)
    {
        // 获取活跃的波次规则
        var activeRules = await GetActiveWaveRules();
        
        foreach (var rule in activeRules)
        {
            // 预计算符合规则的订单ID列表
            var matchingInoutIds = await ComputeMatchingInouts(rule);
            
            // 存储到Redis
            await _cache.SetAsync(
                $"wave:precompute:{rule.CompanyId}:{rule.RuleId}",
                matchingInoutIds,
                TimeSpan.FromMinutes(10));
        }
    }
}
```

---

## 四、批量INSERT优化

### 4.1 问题分析

**问题SQL**:
```sql
INSERT INTO Inout_{@_ST[Combine]}([area_type],[as_id],...共123个字段...) 
Values(@0,@1,...) ; 
INSERT INTO Inout_{@_ST[Combine]}(...) Values(...) ; 
-- 重复16次
```

**问题**: 一次性插入16条记录，每条记录123个字段，单次执行时间12-22秒

### 4.2 优化方案

#### 方案1: 分批插入
```csharp
// 原代码: 一次性插入所有记录
public void BatchInsert(List<Inout> inouts)
{
    // 一次性插入所有
    this.Insert(inouts);
}

// 优化代码: 分批插入
public async Task BatchInsertOptimized(List<Inout> inouts)
{
    const int batchSize = 5;  // 每批5条
    
    for (int i = 0; i < inouts.Count; i += batchSize)
    {
        var batch = inouts.Skip(i).Take(batchSize).ToList();
        await this.InsertAsync(batch);
    }
}
```

#### 方案2: 使用SqlBulkCopy
```csharp
public void BulkInsert(List<Inout> inouts)
{
    using (var bulkCopy = new SqlBulkCopy(connectionString))
    {
        bulkCopy.DestinationTableName = "Inout_1";
        bulkCopy.BatchSize = 100;
        bulkCopy.BulkCopyTimeout = 60;
        
        var dataTable = ConvertToDataTable(inouts);
        bulkCopy.WriteToServer(dataTable);
    }
}
```

---

## 五、后台任务UPDATE优化

### 5.1 问题分析

**问题SQL**:
```sql
UPDATE Inout_{@_ST[Combine]} 
SET [logistics_company] = @1, [logistics_company_code] = @2, [plan_delivery_date] = @3 
OUTPUT deleted.[inout_id] 
WHERE [inout_id] = @0 AND co_id = 10608437
```

**可能原因**:
1. 表锁竞争 - 多个任务同时更新
2. 触发器开销
3. 索引维护成本

### 5.2 优化方案

```csharp
// 1. 批量更新改为分批小批量
public async Task UpdateLogisticsInfoBatch(List<InoutLogisticsUpdate> updates)
{
    const int batchSize = 10;
    
    foreach (var batch in updates.Chunk(batchSize))
    {
        await UpdateLogisticsInfoAsync(batch);
        await Task.Delay(100);  // 短暂延迟，减少锁竞争
    }
}

// 2. 使用ROWLOCK提示减少锁范围
public void UpdateWithRowLock(long inoutId, string logisticsCompany)
{
    var sql = @"
        UPDATE Inout_{@_ST[Combine]} WITH (ROWLOCK)
        SET logistics_company = @1
        WHERE inout_id = @0 AND co_id = @2";
    
    this.Execute(sql, inoutId, logisticsCompany, this.CompanyId);
}
```

---

## 六、监控与告警建议

### 6.1 关键指标监控

```sql
-- 监控慢SQL数量趋势
CompanyId: 10608437 AND slow.sql AND Duration > 5000
| SELECT 
    date_format(__time__, '%Y-%m-%d %H:00:00') as hour,
    COUNT(*) as slow_sql_count,
    AVG(Duration) as avg_duration,
    MAX(Duration) as max_duration
  GROUP BY hour
  ORDER BY hour
```

### 6.2 告警规则

| 指标 | 阈值 | 告警级别 |
|------|------|---------|
| 单次查询时间 | > 10秒 | 警告 |
| 单次查询时间 | > 20秒 | 严重 |
| 1小时内慢SQL数量 | > 50条 | 警告 |
| 1小时内慢SQL数量 | > 100条 | 严重 |

### 6.3 日志增强建议

```csharp
// 在关键位置添加性能日志
public List<Inout> GetAll(WaveCreateCondition condition)
{
    var sw = Stopwatch.StartNew();
    try
    {
        var result = this.InoutDA.GetAll(condition);
        
        // 记录查询性能
        if (sw.ElapsedMilliseconds > 3000)
        {
            Jst.Log.ExceptionLogger.Log("Wave.Performance", "GetAll", new
            {
                CompanyId = this.CompanyId,
                WarehouseId = condition.WarehouseId,
                Duration = sw.ElapsedMilliseconds,
                ResultCount = result.Count,
                HasSkuFuzzyMatch = condition.SkuIds?.Any(s => s.StartsWith("*")) ?? false
            }.ToJsonString());
        }
        
        return result;
    }
    finally
    {
        sw.Stop();
    }
}
```

---

## 七、实施计划

### 第一阶段 (1-2周) - 紧急优化
1. ✅ 修改SKU模糊匹配逻辑，改为后缀匹配
2. ✅ 添加查询性能日志
3. ✅ 评估移除强制索引提示的影响

### 第二阶段 (2-4周) - 核心优化
1. 实现数据库层分页
2. 添加波次查询专用索引
3. 优化批量INSERT逻辑

### 第三阶段 (1-2月) - 架构优化
1. 引入缓存层
2. 实现异步预计算
3. 建立完善的监控告警体系

---

## 八、预期效果

| 优化项 | 预期提升 | 实施难度 |
|--------|---------|---------|
| SKU模糊匹配优化 | 50-70% | 低 |
| 数据库层分页 | 30-50% | 中 |
| 索引优化 | 20-40% | 低 |
| 缓存层 | 60-80% | 高 |

**综合预期**: 波次查询响应时间从平均8.5秒降低到2-3秒

---

## 九、风险评估

| 风险项 | 影响 | 缓解措施 |
|--------|------|---------|
| SKU后缀匹配可能影响业务 | 中 | 先在测试环境验证，与业务确认 |
| 分页逻辑修改可能引入bug | 高 | 充分测试，灰度发布 |
| 新索引可能影响写入性能 | 低 | 监控INSERT/UPDATE性能 |

---

## 十、最新日志分析 (2025-12-15 17:41 更新)

### 10.1 最新6小时日志统计

基于最新SLS查询 (时间范围: 2025-12-15 11:41 - 17:41)，发现以下问题：

| 问题类型 | 数量 | 执行时间范围 | 状态 |
|---------|------|-------------|------|
| 波次查询 (WaveController:GetInoutsByRuleId) | ~25条 | 5,724ms - 8,606ms | **持续存在** |
| 库存同步任务 (LinkWareHouseItemSkuSyncTask) | ~5条 | 7,869ms - 15,670ms | **新发现** |
| 库存查询 (PackController:GetPackItems) | ~4条 | 13,043ms - 21,587ms | **新发现** |
| 订单审核/更新 (OrderAuditTask/OrderConvertTask) | ~10条 | 1,153ms - 4,212ms | 中等 |
| 发货验货 (DeliverController) | ~8条 | 1,462ms - 3,786ms | 中等 |

### 10.2 波次查询问题详细分析

**典型慢SQL示例** (来自最新日志):
```sql
SELECT * FROM Inout_{@_ST[Combine]} i with(INDEX(IX_Inout_1_co_id_warehouse_id)) 
WHERE i.wave_id=0 AND i.warehouse_id=37 AND i.co_id=10608437 
  AND i.status IN ('Delivering','WaitChoice') 
  AND i.sku_qty<=1 AND i.sku_qty>=1 
  AND i.type = 'SaleOut' 
  AND i.pay_date>='2025/11/30 17:00:00' 
  AND i.pay_date<='2025/12/14 05:00:00' 
  AND i.link_co_id IN (14587903) 
  AND (i.label_codes not like '%SpecialOrder%') 
  AND EXISTS (SELECT 1 FROM InoutItem_{@_ST[Combine]} ii 
              WHERE ii.inout_id=i.inout_id AND ii.sku_id like '%NYSD%')
ORDER BY pay_date
```

**用户操作模式分析**:
- 主要操作用户: 11677510
- 常用SKU模糊匹配模式: `*LHL`, `*ETHZH`, `*NYSD`, `*SD30`, `*SD50`, `*SD20`, `*CD`, `*BXJ`
- 时间范围: 通常查询近14天的数据
- 货主ID: 11507207, 14587903

### 10.3 新发现问题: 库存查询慢

**问题SQL**:
```sql
SELECT pack_item_id, link_co_id, sku_id, sku_name, properties_value, 
       sku_batch_id, produced_date, expire_date, qty, bin_type, area_type, modified, bin 
FROM PackItem_{@_ST[Combine]} 
WHERE co_id=@0 AND warehouse_id IN (@1) 
  AND bin_type IN (@2,@3) 
  AND (pack_id='' or pack_id=bin)
```

**执行时间**: 13,043ms - 21,587ms

**问题分析**:
1. 查询条件 `(pack_id='' or pack_id=bin)` 导致索引效率低
2. 返回数据量大 (GetBigData 类型)
3. 缺少针对性索引

**优化建议**:
```sql
-- 添加复合索引
CREATE NONCLUSTERED INDEX IX_PackItem_query 
ON PackItem_1 (co_id, warehouse_id, bin_type, pack_id)
INCLUDE (pack_item_id, link_co_id, sku_id, sku_name, properties_value, 
         sku_batch_id, produced_date, expire_date, qty, area_type, modified, bin);
```

### 10.4 新发现问题: 库存同步任务慢

**问题SQL**:
```sql
SELECT link_co_id, sku_id, MIN(created) created 
FROM WarehouseInventory_{@_ST[Combine]} 
WHERE co_id=@0 AND link_co_id<>@0 
GROUP BY link_co_id, sku_id
```

**执行时间**: 7,869ms - 15,670ms

**问题分析**:
1. 全表扫描进行GROUP BY
2. 定时任务频繁执行 (每小时)
3. 数据量大

**优化建议**:
```sql
-- 添加覆盖索引
CREATE NONCLUSTERED INDEX IX_WarehouseInventory_sync 
ON WarehouseInventory_1 (co_id, link_co_id, sku_id)
INCLUDE (created);

-- 或者考虑使用物化视图/缓存
```

### 10.5 用户行为分析

从日志中提取的用户操作模式：

| 用户ID | 主要操作 | 频率 | 影响 |
|--------|---------|------|------|
| 11677510 | 波次查询 (SKU模糊匹配) | 高 | 主要慢SQL来源 |
| 14069262 | 打印/发货验货 | 中 | 中等影响 |
| 20270848 | 批量验货 | 中 | 中等影响 |
| 19885475 | 库存查询 | 低 | 单次耗时长 |
| 13160093 | 库存查询 | 低 | 单次耗时长 |

### 10.6 时间分布分析

```
12:57 - 13:02  波次查询集中爆发 (用户11677510)
14:00 - 14:04  波次查询集中爆发 (用户11677510)
14:47 - 14:48  波次查询集中爆发 (用户11677510)
```

**结论**: 用户11677510的波次查询操作是主要性能瓶颈来源，建议：
1. 与该用户沟通，了解业务需求
2. 考虑限制SKU模糊匹配的使用
3. 提供更高效的查询方式

---

## 十一、代码级别详细分析

### 11.1 波次查询SQL生成逻辑 (InoutDAWaveExists.cs)

**关键代码路径**:
```
GetInoutsExists() 
  → GetConditionSqlExists() 
    → GetWhereSqlExists()      // 主表条件
    → GetInoutItemSqlExists()  // EXISTS子查询
      → GetSkuLabelSqlExists() // SKU标签子查询
      → GetInnerPackItemSqlExists() // 库存子查询
```

**问题代码1: SKU模糊匹配** (第139-143行)
```csharp
if (condition.SkuIds.Count == 1 && condition.SkuIds[0].Trim()[0] == '*')
{
    sql.Append($" AND ii.{InoutItemSchema.ColumnName.SkuId} like @{ps.Count}");
    ps.Add($"%{condition.SkuIds[0].Trim().Substring(1)}%");  // 生成 LIKE '%xxx%'
}
```

**问题代码2: 多层EXISTS嵌套** (第120-180行)
```csharp
// 主查询 → InoutItem子查询
sql.Append($" AND EXISTS (SELECT 1 FROM {InoutItemSchema.Singleton.GetTableNameForSql()} ii")
    .Append(" WHERE ii.inout_id=i.inout_id");

// InoutItem子查询 → SkuLabel子查询 (如果需要)
sql.Append(GetSkuLabelSqlExists(condition, ps));

// InoutItem子查询 → PackItem子查询 (如果需要)
sql.Append(GetInnerPackItemSqlExists(condition, ps));
```

### 11.2 应用层分页问题 (WaveFacade.cs)

**问题代码** (第750-793行):
```csharp
public BasePageResponse<Inout> GetInoutsByRuleId(BasePageRequest<GenerateWaveRequest> baseRequest)
{
    // ...
    var inouts = waveCreateRule.GetAll();  // 一次性加载所有数据到内存
    
    // 应用层排序
    if (!string.IsNullOrWhiteSpace(request.OrderByField))
    {
        if (request.OrderByField == "Skus" && request.OrderByIsAsc)
            inouts = inouts.OrderBy(x => x.Skus.Split(".")[1]).ToList();
        // ... 其他排序逻辑
    }
    
    // 应用层分页
    inouts = inouts.Skip((dataPage.PageIndex - 1) * dataPage.PageSize)
                   .Take(dataPage.PageSize).ToList();
    // ...
}
```

**问题**:
1. `GetAll()` 加载全部数据，数据量大时内存压力大
2. 排序在应用层进行，无法利用数据库索引
3. 分页在应用层进行，浪费数据库和网络资源

---

## 十二、完整优化实施清单

### 第一阶段 (紧急 - 1周内)

| 序号 | 优化项 | 文件 | 预期效果 | 风险 |
|------|--------|------|---------|------|
| 1.1 | SKU模糊匹配改为后缀匹配 | InoutDAWaveExists.cs:139-143 | 50-70% | 中 |
| 1.2 | 添加SKU模糊匹配长度限制 | InoutDAWaveExists.cs | 减少误用 | 低 |
| 1.3 | 添加性能日志 | WaveFacade.cs | 便于监控 | 低 |

### 第二阶段 (重要 - 2-4周)

| 序号 | 优化项 | 文件 | 预期效果 | 风险 |
|------|--------|------|---------|------|
| 2.1 | 数据库层分页 | WaveFacade.cs, InoutDA.cs | 30-50% | 中 |
| 2.2 | 移除强制索引提示 | WaveCreateRuleFactory | 10-20% | 低 |
| 2.3 | 添加波次查询专用索引 | 数据库 | 20-40% | 低 |
| 2.4 | 优化PackItem查询索引 | 数据库 | 30-50% | 低 |

### 第三阶段 (长期 - 1-2月)

| 序号 | 优化项 | 说明 | 预期效果 | 风险 |
|------|--------|------|---------|------|
| 3.1 | 引入Redis缓存 | 缓存波次规则配置 | 60-80% | 中 |
| 3.2 | 异步预计算 | 定时预计算波次匹配 | 70-90% | 高 |
| 3.3 | 库存同步任务优化 | 增量同步替代全量 | 50-70% | 中 |

---

## 十三、SQL索引优化脚本

### 13.1 波次查询优化索引

```sql
-- 检查现有索引
SELECT 
    i.name AS IndexName,
    STRING_AGG(c.name, ', ') WITHIN GROUP (ORDER BY ic.key_ordinal) AS IndexColumns,
    i.type_desc AS IndexType
FROM sys.indexes i
INNER JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id
INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
WHERE i.object_id = OBJECT_ID('Inout_1')
GROUP BY i.name, i.type_desc
ORDER BY i.name;

-- 创建波次查询优化索引
IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_Inout_wave_query_v2')
BEGIN
    CREATE NONCLUSTERED INDEX IX_Inout_wave_query_v2 
    ON Inout_1 (co_id, warehouse_id, wave_id, status, type)
    INCLUDE (pay_date, sku_qty, link_co_id, label_codes, skus, inout_id)
    WITH (ONLINE = ON);
END

-- 创建InoutItem优化索引
IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_InoutItem_wave_query')
BEGIN
    CREATE NONCLUSTERED INDEX IX_InoutItem_wave_query 
    ON InoutItem_1 (inout_id, sku_id)
    WITH (ONLINE = ON);
END
```

### 13.2 库存查询优化索引

```sql
-- PackItem表优化索引
IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_PackItem_query_v2')
BEGIN
    CREATE NONCLUSTERED INDEX IX_PackItem_query_v2 
    ON PackItem_1 (co_id, warehouse_id, bin_type)
    INCLUDE (pack_item_id, link_co_id, sku_id, sku_name, properties_value, 
             sku_batch_id, produced_date, expire_date, qty, area_type, modified, bin, pack_id)
    WITH (ONLINE = ON);
END

-- WarehouseInventory表优化索引
IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_WarehouseInventory_sync')
BEGIN
    CREATE NONCLUSTERED INDEX IX_WarehouseInventory_sync 
    ON WarehouseInventory_1 (co_id, link_co_id)
    INCLUDE (sku_id, created)
    WITH (ONLINE = ON);
END
```

---

## 十四、监控查询模板

### 14.1 实时监控查询

```
-- SLS查询: 实时监控商家10608437的慢SQL
project_alias: 慢sql日志
query: CompanyId: 10608437 AND slow.sql AND Duration > 5000
time_range: 1h
max_logs: 100
```

### 14.2 按模块统计

```
-- SLS查询: 按模块统计慢SQL
project_alias: 慢sql日志
query: CompanyId: 10608437 AND slow.sql AND Duration > 5000 
| SELECT Modual, COUNT(*) as count, AVG(Duration) as avg_duration, MAX(Duration) as max_duration 
  GROUP BY Modual ORDER BY count DESC
time_range: 1d
```

### 14.3 波次查询专项监控

```
-- SLS查询: 波次查询专项监控
project_alias: 慢sql日志
query: CompanyId: 10608437 AND WaveController:GetInoutsByRuleId AND Duration > 3000
time_range: 6h
max_logs: 200
```

---

**文档版本**: 1.1
**创建时间**: 2025-12-15
**最后更新**: 2025-12-15 17:45
**作者**: AI Assistant
